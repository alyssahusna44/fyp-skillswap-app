-- =============================================
-- Application Database Schema
-- Extends Supabase Authentication
-- =============================================

-- Enable uuid generation extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================
-- PROFILES TABLE (extends auth.users)
-- =============================================
CREATE TABLE public.profiles (
    id UUID REFERENCES auth.users(id) PRIMARY KEY,
    bio TEXT,
    profile_picture_url VARCHAR(255),
    location VARCHAR(100),
    average_rating DECIMAL(3,2) DEFAULT 0.00,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- USER SKILLS TABLE
-- =============================================
CREATE TABLE public.user_skills (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    skill_id BIGINT NOT NULL,
    skill_level VARCHAR(50) DEFAULT 'LEARN', -- LEARN, TEACH, etc.
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- SKILLS TABLE
-- =============================================
CREATE TABLE public.skills (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    category VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- USERS TABLE (additional user data beyond auth.users)
-- =============================================
CREATE TABLE public.users (
    id UUID REFERENCES auth.users(id) PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    password_hash VARCHAR(255), -- This will be managed by Supabase Auth
    name VARCHAR(255),
    is_verified BOOLEAN DEFAULT FALSE,
    verification_code VARCHAR(255),
    verification_requested_at TIMESTAMP WITH TIME ZONE,
    request_attempts INTEGER DEFAULT 0,
    email_verified_at TIMESTAMP WITH TIME ZONE,
    remember_token VARCHAR(100),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- =============================================
-- AVAILABILITY TABLE
-- =============================================
CREATE TABLE public.availability (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    day_of_week VARCHAR(10) NOT NULL, -- MON, TUE, WED, THU, FRI, SAT, SUN
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    is_recurring BOOLEAN DEFAULT TRUE,
    date_specific DATE, -- for one-time availability
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT check_day_of_week CHECK (day_of_week IN ('MON','TUE','WED','THU','FRI','SAT','SUN')),
    CONSTRAINT check_time_order CHECK (start_time < end_time)
);

-- =============================================
-- CHAT ROOMS TABLE
-- =============================================
CREATE TABLE public.chat_rooms (
    id BIGSERIAL PRIMARY KEY,
    skill_1_id BIGINT REFERENCES public.skills(id) NOT NULL,
    skill_2_id BIGINT REFERENCES public.skills(id) NOT NULL,
    user2_id UUID REFERENCES auth.users(id) NOT NULL,
    creator_id UUID REFERENCES auth.users(id) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT different_skills CHECK (skill_1_id != skill_2_id)
);

-- =============================================
-- CHAT MESSAGES TABLE
-- =============================================
CREATE TABLE public.chat_messages (
    id BIGSERIAL PRIMARY KEY,
    chat_room_id BIGINT REFERENCES public.chat_rooms(id) ON DELETE CASCADE NOT NULL,
    sender_id UUID REFERENCES auth.users(id) NOT NULL,
    message_text TEXT NOT NULL,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_read BOOLEAN DEFAULT FALSE
);

-- =============================================
-- REVIEWS TABLE
-- =============================================
CREATE TABLE public.reviews (
    id BIGSERIAL PRIMARY KEY,
    reviewer_id UUID REFERENCES auth.users(id) NOT NULL,
    reviewed_user_id UUID REFERENCES auth.users(id) NOT NULL,
    rating INTEGER NOT NULL,
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT check_rating CHECK (rating >= 1 AND rating <= 5),
    CONSTRAINT no_self_review CHECK (reviewer_id != reviewed_user_id)
);

-- =============================================
-- RATINGS TABLE (separate from reviews for flexibility)
-- =============================================
CREATE TABLE public.ratings (
    id BIGSERIAL PRIMARY KEY,
    reviewer_id UUID REFERENCES auth.users(id) NOT NULL,
    reviewed_id UUID REFERENCES auth.users(id) NOT NULL,
    stars INTEGER NOT NULL,
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT check_stars CHECK (stars >= 1 AND stars <= 5),
    CONSTRAINT no_self_rating CHECK (reviewer_id != reviewed_id)
);

-- =============================================
-- INDEXES for better performance
-- =============================================
CREATE INDEX idx_profiles_user_id ON public.profiles(id);
CREATE INDEX idx_user_skills_user_id ON public.user_skills(user_id);
CREATE INDEX idx_user_skills_skill_id ON public.user_skills(skill_id);
CREATE INDEX idx_availability_user_id ON public.availability(user_id);
CREATE INDEX idx_availability_day ON public.availability(day_of_week);
CREATE INDEX idx_chat_rooms_users ON public.chat_rooms(user2_id, creator_id);
CREATE INDEX idx_chat_messages_room_id ON public.chat_messages(chat_room_id);
CREATE INDEX idx_chat_messages_sender ON public.chat_messages(sender_id);
CREATE INDEX idx_chat_messages_sent_at ON public.chat_messages(sent_at);
CREATE INDEX idx_reviews_reviewer ON public.reviews(reviewer_id);
CREATE INDEX idx_reviews_reviewed_user ON public.reviews(reviewed_user_id);
CREATE INDEX idx_ratings_reviewer ON public.ratings(reviewer_id);
CREATE INDEX idx_ratings_reviewed ON public.ratings(reviewed_id);

-- =============================================
-- ROW LEVEL SECURITY POLICIES
-- =============================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.skills ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.availability ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ratings ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Users can view all profiles" ON public.profiles
    FOR SELECT USING (true);

CREATE POLICY "Users can update own profile" ON public.profiles
    FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile" ON public.profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

-- User skills policies
CREATE POLICY "Users can view all user skills" ON public.user_skills
    FOR SELECT USING (true);

CREATE POLICY "Users can manage own skills" ON public.user_skills
    FOR ALL USING (auth.uid() = user_id);

-- Skills policies (read-only for most users)
CREATE POLICY "Anyone can view skills" ON public.skills
    FOR SELECT USING (true);

-- Users table policies
CREATE POLICY "Users can view all users" ON public.users
    FOR SELECT USING (true);

CREATE POLICY "Users can update own data" ON public.users
    FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert own data" ON public.users
    FOR INSERT WITH CHECK (auth.uid() = id);

-- Availability policies
CREATE POLICY "Users can view all availability" ON public.availability
    FOR SELECT USING (true);

CREATE POLICY "Users can manage own availability" ON public.availability
    FOR ALL USING (auth.uid() = user_id);

-- Chat rooms policies
CREATE POLICY "Users can view rooms they're part of" ON public.chat_rooms
    FOR SELECT USING (auth.uid() = user2_id OR auth.uid() = creator_id);

CREATE POLICY "Users can create chat rooms" ON public.chat_rooms
    FOR INSERT WITH CHECK (auth.uid() = creator_id);

CREATE POLICY "Users can update rooms they created" ON public.chat_rooms
    FOR UPDATE USING (auth.uid() = creator_id);

-- Chat messages policies
CREATE POLICY "Users can view messages in their rooms" ON public.chat_messages
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.chat_rooms cr 
            WHERE cr.id = chat_room_id 
            AND (cr.user2_id = auth.uid() OR cr.creator_id = auth.uid())
        )
    );

CREATE POLICY "Users can send messages to their rooms" ON public.chat_messages
    FOR INSERT WITH CHECK (
        auth.uid() = sender_id AND
        EXISTS (
            SELECT 1 FROM public.chat_rooms cr 
            WHERE cr.id = chat_room_id 
            AND (cr.user2_id = auth.uid() OR cr.creator_id = auth.uid())
        )
    );

CREATE POLICY "Users can update own messages" ON public.chat_messages
    FOR UPDATE USING (auth.uid() = sender_id);

-- Reviews policies
CREATE POLICY "Users can view all reviews" ON public.reviews
    FOR SELECT USING (true);

CREATE POLICY "Users can create reviews" ON public.reviews
    FOR INSERT WITH CHECK (auth.uid() = reviewer_id);

CREATE POLICY "Users can update own reviews" ON public.reviews
    FOR UPDATE USING (auth.uid() = reviewer_id);

-- Ratings policies
CREATE POLICY "Users can view all ratings" ON public.ratings
    FOR SELECT USING (true);

CREATE POLICY "Users can create ratings" ON public.ratings
    FOR INSERT WITH CHECK (auth.uid() = reviewer_id);

CREATE POLICY "Users can update own ratings" ON public.ratings
    FOR UPDATE USING (auth.uid() = reviewer_id);

-- =============================================
-- FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = timezone('utc'::text, now());
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Add updated_at triggers
CREATE TRIGGER handle_updated_at_profiles 
    BEFORE UPDATE ON public.profiles 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_user_skills 
    BEFORE UPDATE ON public.user_skills 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_skills 
    BEFORE UPDATE ON public.skills 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_users 
    BEFORE UPDATE ON public.users 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_availability 
    BEFORE UPDATE ON public.availability 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_chat_rooms 
    BEFORE UPDATE ON public.chat_rooms 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_reviews 
    BEFORE UPDATE ON public.reviews 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

CREATE TRIGGER handle_updated_at_ratings 
    BEFORE UPDATE ON public.ratings 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- Function to create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id)
    VALUES (NEW.id);
    
    INSERT INTO public.users (id, email, name, email_verified_at)
    VALUES (
        NEW.id, 
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'name', NEW.raw_user_meta_data->>'full_name'),
        NEW.email_confirmed_at
    );
    
    RETURN NEW;
END;
$$ language 'plpgsql' security definer;

-- Trigger to create profile on user signup
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to update average rating
CREATE OR REPLACE FUNCTION public.update_average_rating()
RETURNS TRIGGER AS $$
BEGIN
    -- Update average rating in profiles table
    UPDATE public.profiles 
    SET average_rating = (
        SELECT COALESCE(AVG(rating), 0)::DECIMAL(3,2)
        FROM public.reviews 
        WHERE reviewed_user_id = COALESCE(NEW.reviewed_user_id, OLD.reviewed_user_id)
    )
    WHERE id = COALESCE(NEW.reviewed_user_id, OLD.reviewed_user_id);
    
    RETURN COALESCE(NEW, OLD);
END;
$$ language 'plpgsql' security definer;

-- Trigger to update average rating on review changes
CREATE TRIGGER update_rating_on_review_change
    AFTER INSERT OR UPDATE OR DELETE ON public.reviews
    FOR EACH ROW EXECUTE PROCEDURE public.update_average_rating();

-- =============================================
-- SAMPLE DATA
-- =============================================

-- Insert some sample skills
INSERT INTO public.skills (name, category) VALUES
('JavaScript', 'Programming'),
('Flutter', 'Framework'),
('React', 'Frontend'),
('Node.js', 'Backend'),
('PostgreSQL', 'Database'),
('Guitar', 'Music'),
('Piano', 'Music'),
('German', 'Language'),
('Mandarin', 'Language'),
('Cooking', 'Life Skills'),
('Photography', 'Creative'),
('Boxing', 'Fitness');

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT SELECT ON ALL TABLES IN SCHEMA public TO anon;

-- =============================================
-- Database Functions for Profile Management
-- =============================================

-- Function to upsert (create or update) user profile with skills and availability
CREATE OR REPLACE FUNCTION upsert_user_profile(
    p_user_id UUID,
    p_name TEXT,
    p_bio TEXT DEFAULT NULL,
    p_location TEXT DEFAULT NULL,
    p_profile_picture_url TEXT DEFAULT NULL,
    p_skills_to_teach TEXT[] DEFAULT '{}',
    p_skills_to_learn TEXT[] DEFAULT '{}',
    p_availability JSONB[] DEFAULT '{}'
)
RETURNS VOID AS $$
DECLARE
    skill_name TEXT;
    skill_id BIGINT;
    availability_item JSONB;
BEGIN
    -- Update profiles table
    UPDATE public.profiles 
    SET 
        bio = p_bio,
        location = p_location,
        profile_picture_url = p_profile_picture_url,
        updated_at = timezone('utc'::text, now())
    WHERE id = p_user_id;

    -- Update users table
    UPDATE public.users 
    SET 
        name = p_name,
        updated_at = timezone('utc'::text, now())
    WHERE id = p_user_id;

    -- Clear existing user skills
    DELETE FROM public.user_skills WHERE user_id = p_user_id;

    -- Add skills to teach
    FOREACH skill_name IN ARRAY p_skills_to_teach
    LOOP
        -- Get or create skill
        INSERT INTO public.skills (name, category) 
        VALUES (skill_name, 'General')
        ON CONFLICT (name) DO NOTHING;
        
        SELECT id INTO skill_id 
        FROM public.skills 
        WHERE name = skill_name;
        
        -- Add user skill relationship
        INSERT INTO public.user_skills (user_id, skill_id, skill_level)
        VALUES (p_user_id, skill_id, 'TEACH');
    END LOOP;

    -- Add skills to learn
    FOREACH skill_name IN ARRAY p_skills_to_learn
    LOOP
        -- Get or create skill
        INSERT INTO public.skills (name, category) 
        VALUES (skill_name, 'General')
        ON CONFLICT (name) DO NOTHING;
        
        SELECT id INTO skill_id 
        FROM public.skills 
        WHERE name = skill_name;
        
        -- Add user skill relationship
        INSERT INTO public.user_skills (user_id, skill_id, skill_level)
        VALUES (p_user_id, skill_id, 'LEARN');
    END LOOP;

    -- Clear existing availability
    DELETE FROM public.availability WHERE user_id = p_user_id;

    -- Add new availability
    FOREACH availability_item IN ARRAY p_availability
    LOOP
        INSERT INTO public.availability (
            user_id,
            day_of_week,
            start_time,
            end_time,
            is_recurring,
            date_specific
        ) VALUES (
            p_user_id,
            availability_item->>'day_of_week',
            (availability_item->>'start_time')::TIME,
            (availability_item->>'end_time')::TIME,
            COALESCE((availability_item->>'is_recurring')::BOOLEAN, true),
            CASE 
                WHEN availability_item->>'date_specific' IS NOT NULL 
                THEN (availability_item->>'date_specific')::DATE 
                ELSE NULL 
            END
        );
    END LOOP;

END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permissions on functions
GRANT EXECUTE ON FUNCTION upsert_user_profile TO authenticated;

-- Create a bucket for profile pictures
insert into storage.buckets (id, name, public)
values ('avatars', 'avatars', true)
on conflict (id) do nothing;

-- Add the missing foreign key constraint for user_skills -> skills
ALTER TABLE public.user_skills 
ADD CONSTRAINT user_skills_skill_id_fkey 
FOREIGN KEY (skill_id) 
REFERENCES public.skills(id) 
ON DELETE CASCADE;

-- Create policy to allow authenticated users to upload their own avatars
CREATE POLICY "Users can upload their own avatar"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (
  bucket_id = 'avatars' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Create policy to allow authenticated users to update their own avatars
CREATE POLICY "Users can update their own avatar"
ON storage.objects FOR UPDATE
TO authenticated
USING (
  bucket_id = 'avatars' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Create policy to allow authenticated users to delete their own avatars
CREATE POLICY "Users can delete their own avatar"
ON storage.objects FOR DELETE
TO authenticated
USING (
  bucket_id = 'avatars' AND
  (storage.foldername(name))[1] = auth.uid()::text
);

-- Create policy to allow anyone to view avatars (since bucket is public)
CREATE POLICY "Anyone can view avatars"
ON storage.objects FOR SELECT
TO public
USING (bucket_id = 'avatars');

-- Add phone_number column to profiles table
ALTER TABLE public.profiles 
ADD COLUMN phone_number VARCHAR(20);

-- Add a check constraint for basic validation
ALTER TABLE public.profiles 
ADD CONSTRAINT check_phone_format 
CHECK (phone_number IS NULL OR phone_number ~ '^\+?[0-9\s\-\(\)]+$');

CREATE OR REPLACE FUNCTION upsert_user_profile(
    p_user_id UUID,
    p_name TEXT,
    p_bio TEXT DEFAULT NULL,
    p_location TEXT DEFAULT NULL,
    p_phone_number TEXT DEFAULT NULL,  -- Add this parameter
    p_profile_picture_url TEXT DEFAULT NULL,
    p_skills_to_teach TEXT[] DEFAULT '{}',
    p_skills_to_learn TEXT[] DEFAULT '{}',
    p_availability JSONB[] DEFAULT '{}'
)
RETURNS VOID AS $$
BEGIN
    -- Update profiles table
    UPDATE public.profiles 
    SET 
        bio = p_bio,
        location = p_location,
        phone_number = p_phone_number,  -- Add this
        profile_picture_url = p_profile_picture_url,
        updated_at = timezone('utc'::text, now())
    WHERE id = p_user_id;
    
    -- ... rest of function
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- ADDITIONAL RLS POLICIES FOR SEARCH FEATURE
-- Run these in your Supabase SQL Editor
-- =============================================

-- Allow authenticated users to insert new skills
-- (Currently your profile form can create new skills, but there's no INSERT policy)
CREATE POLICY "Authenticated users can create skills" ON public.skills
    FOR INSERT 
    TO authenticated
    WITH CHECK (true);

-- =============================================
-- ADDITIONAL INDEXES FOR SEARCH PERFORMANCE
-- =============================================

-- Index for filtering users by skills (speeds up skill-based searches)
CREATE INDEX IF NOT EXISTS idx_user_skills_skill_level 
    ON public.user_skills(skill_level);

-- Composite index for skill filtering
CREATE INDEX IF NOT EXISTS idx_user_skills_user_skill_level 
    ON public.user_skills(user_id, skill_level);

-- Index for location-based searches (case-insensitive)
CREATE INDEX IF NOT EXISTS idx_profiles_location_lower 
    ON public.profiles(LOWER(location));

-- Index for user name searches (case-insensitive)
CREATE INDEX IF NOT EXISTS idx_users_name_lower 
    ON public.users(LOWER(name));

-- =============================================
-- OPTIONAL: ADD FULL TEXT SEARCH CAPABILITIES
-- =============================================

-- Add a full-text search column for user names (more advanced searching)
ALTER TABLE public.users 
ADD COLUMN IF NOT EXISTS name_search_vector tsvector 
GENERATED ALWAYS AS (to_tsvector('english', COALESCE(name, ''))) STORED;

-- Index for full-text search
CREATE INDEX IF NOT EXISTS idx_users_name_search 
    ON public.users USING GIN(name_search_vector);

-- Add a full-text search column for profiles bio
ALTER TABLE public.profiles 
ADD COLUMN IF NOT EXISTS bio_search_vector tsvector 
GENERATED ALWAYS AS (to_tsvector('english', COALESCE(bio, ''))) STORED;

-- Index for bio full-text search
CREATE INDEX IF NOT EXISTS idx_profiles_bio_search 
    ON public.profiles USING GIN(bio_search_vector);

-- =============================================
-- VERIFY YOUR CURRENT RLS POLICIES ARE ACTIVE
-- =============================================

-- Check if RLS is enabled on all tables (should return true for all)
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('profiles', 'users', 'user_skills', 'skills', 'availability');

-- View all current policies
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual, with_check
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- =============================================
-- OPTIONAL: ADD RATE LIMITING FOR SEARCH
-- (Prevents abuse of the search feature)
-- =============================================

-- Create a table to track search requests
CREATE TABLE IF NOT EXISTS public.search_rate_limit (
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    search_count INTEGER DEFAULT 0,
    window_start TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()),
    PRIMARY KEY (user_id, window_start)
);

-- Enable RLS
ALTER TABLE public.search_rate_limit ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only see their own rate limit data
CREATE POLICY "Users can view own rate limits" ON public.search_rate_limit
    FOR SELECT USING (auth.uid() = user_id);

-- Policy: Users can insert their own rate limit data
CREATE POLICY "Users can insert own rate limits" ON public.search_rate_limit
    FOR INSERT WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update their own rate limit data
CREATE POLICY "Users can update own rate limits" ON public.search_rate_limit
    FOR UPDATE USING (auth.uid() = user_id);

-- Function to check and increment rate limit
CREATE OR REPLACE FUNCTION check_search_rate_limit(
    max_searches INTEGER DEFAULT 100,
    window_minutes INTEGER DEFAULT 60
)
RETURNS BOOLEAN AS $$
DECLARE
    current_count INTEGER;
    user_uuid UUID;
BEGIN
    user_uuid := auth.uid();
    
    IF user_uuid IS NULL THEN
        RETURN FALSE;
    END IF;
    
    -- Clean old windows
    DELETE FROM public.search_rate_limit 
    WHERE user_id = user_uuid 
    AND window_start < timezone('utc'::text, now()) - (window_minutes || ' minutes')::INTERVAL;
    
    -- Get current count
    SELECT COALESCE(SUM(search_count), 0) 
    INTO current_count
    FROM public.search_rate_limit
    WHERE user_id = user_uuid
    AND window_start >= timezone('utc'::text, now()) - (window_minutes || ' minutes')::INTERVAL;
    
    -- Check if limit exceeded
    IF current_count >= max_searches THEN
        RETURN FALSE;
    END IF;
    
    -- Increment counter
    INSERT INTO public.search_rate_limit (user_id, search_count)
    VALUES (user_uuid, 1)
    ON CONFLICT (user_id, window_start) 
    DO UPDATE SET search_count = public.search_rate_limit.search_count + 1;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION check_search_rate_limit TO authenticated;

-- =============================================
-- VERIFICATION QUERIES
-- =============================================

-- Test that your search queries work
-- Run this to see if the basic search structure is working
SELECT 
    p.id,
    u.name,
    p.location,
    p.bio,
    p.average_rating,
    ARRAY_AGG(DISTINCT s.name) FILTER (WHERE us.skill_level = 'TEACH') as skills_to_teach,
    ARRAY_AGG(DISTINCT s.name) FILTER (WHERE us.skill_level = 'LEARN') as skills_to_learn
FROM public.profiles p
LEFT JOIN public.users u ON u.id = p.id
LEFT JOIN public.user_skills us ON us.user_id = p.id
LEFT JOIN public.skills s ON s.id = us.skill_id
GROUP BY p.id, u.name, p.location, p.bio, p.average_rating
LIMIT 10;

-- =============================================
-- CLEANUP (OPTIONAL - only if you need to undo)
-- =============================================

-- To remove the rate limiting feature if you don't want it:
-- DROP FUNCTION IF EXISTS check_search_rate_limit;
-- DROP TABLE IF EXISTS public.search_rate_limit;

-- To remove full-text search columns:
-- ALTER TABLE public.users DROP COLUMN IF EXISTS name_search_vector;
-- ALTER TABLE public.profiles DROP COLUMN IF EXISTS bio_search_vector;


-- =============================================
-- REVIEWS SYSTEM ENHANCEMENTS
-- Run this in your Supabase SQL Editor
-- =============================================

-- Add a constraint to prevent duplicate reviews
ALTER TABLE public.reviews 
ADD CONSTRAINT unique_review_per_user 
UNIQUE (reviewer_id, reviewed_user_id);

-- =============================================
-- HELPER FUNCTIONS FOR REVIEWS
-- =============================================

-- Function to check if user can review another user
CREATE OR REPLACE FUNCTION can_review_user(
    p_reviewer_id UUID,
    p_reviewed_user_id UUID
)
RETURNS BOOLEAN AS $$
DECLARE
    v_has_interaction BOOLEAN;
BEGIN
    -- Check if users have interacted (had a chat)
    SELECT EXISTS(
        SELECT 1 
        FROM public.chat_rooms
        WHERE (user_1_id = p_reviewer_id AND user_2_id = p_reviewed_user_id)
           OR (user_1_id = p_reviewed_user_id AND user_2_id = p_reviewer_id)
    ) INTO v_has_interaction;
    
    -- Also check if already reviewed
    IF EXISTS(
        SELECT 1 
        FROM public.reviews
        WHERE reviewer_id = p_reviewer_id 
        AND reviewed_user_id = p_reviewed_user_id
    ) THEN
        RETURN FALSE;
    END IF;
    
    RETURN v_has_interaction;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get user's reviews with reviewer details
CREATE OR REPLACE FUNCTION get_user_reviews(p_user_id UUID)
RETURNS TABLE(
    review_id BIGINT,
    reviewer_id UUID,
    reviewer_name TEXT,
    reviewer_profile_pic TEXT,
    rating INTEGER,
    comment TEXT,
    created_at TIMESTAMPTZ
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        r.id as review_id,
        r.reviewer_id,
        u.name as reviewer_name,
        p.profile_picture_url as reviewer_profile_pic,
        r.rating,
        r.comment,
        r.created_at
    FROM public.reviews r
    INNER JOIN public.users u ON u.id = r.reviewer_id
    LEFT JOIN public.profiles p ON p.id = r.reviewer_id
    WHERE r.reviewed_user_id = p_user_id
    ORDER BY r.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get review statistics
CREATE OR REPLACE FUNCTION get_review_stats(p_user_id UUID)
RETURNS TABLE(
    total_reviews BIGINT,
    average_rating NUMERIC,
    five_star INTEGER,
    four_star INTEGER,
    three_star INTEGER,
    two_star INTEGER,
    one_star INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::BIGINT as total_reviews,
        COALESCE(AVG(rating), 0)::NUMERIC(3,2) as average_rating,
        COUNT(CASE WHEN rating = 5 THEN 1 END)::INTEGER as five_star,
        COUNT(CASE WHEN rating = 4 THEN 1 END)::INTEGER as four_star,
        COUNT(CASE WHEN rating = 3 THEN 1 END)::INTEGER as three_star,
        COUNT(CASE WHEN rating = 2 THEN 1 END)::INTEGER as two_star,
        COUNT(CASE WHEN rating = 1 THEN 1 END)::INTEGER as one_star
    FROM public.reviews
    WHERE reviewed_user_id = p_user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to submit or update a review
CREATE OR REPLACE FUNCTION upsert_review(
    p_reviewer_id UUID,
    p_reviewed_user_id UUID,
    p_rating INTEGER,
    p_comment TEXT
)
RETURNS BIGINT AS $$
DECLARE
    v_review_id BIGINT;
BEGIN
    -- Validate rating
    IF p_rating < 1 OR p_rating > 5 THEN
        RAISE EXCEPTION 'Rating must be between 1 and 5';
    END IF;
    
    -- Prevent self-review
    IF p_reviewer_id = p_reviewed_user_id THEN
        RAISE EXCEPTION 'Cannot review yourself';
    END IF;
    
    -- Insert or update review
    INSERT INTO public.reviews (
        reviewer_id,
        reviewed_user_id,
        rating,
        comment
    ) VALUES (
        p_reviewer_id,
        p_reviewed_user_id,
        p_rating,
        p_comment
    )
    ON CONFLICT (reviewer_id, reviewed_user_id)
    DO UPDATE SET
        rating = EXCLUDED.rating,
        comment = EXCLUDED.comment,
        updated_at = timezone('utc'::text, now())
    RETURNING id INTO v_review_id;
    
    RETURN v_review_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION can_review_user TO authenticated;
GRANT EXECUTE ON FUNCTION get_user_reviews TO authenticated;
GRANT EXECUTE ON FUNCTION get_review_stats TO authenticated;
GRANT EXECUTE ON FUNCTION upsert_review TO authenticated;

-- =============================================
-- REVIEW POLICY UPDATES
-- =============================================

-- Drop existing review policies
DROP POLICY IF EXISTS "Users can create reviews" ON public.reviews;
DROP POLICY IF EXISTS "Users can update own reviews" ON public.reviews;

-- New policies with interaction check
CREATE POLICY "Users can create reviews for users they've interacted with" 
ON public.reviews
    FOR INSERT WITH CHECK (
        auth.uid() = reviewer_id 
        AND can_review_user(auth.uid(), reviewed_user_id)
    );

CREATE POLICY "Users can update their own reviews" 
ON public.reviews
    FOR UPDATE USING (auth.uid() = reviewer_id);

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================

CREATE INDEX IF NOT EXISTS idx_reviews_created_at 
    ON public.reviews(created_at DESC);

CREATE INDEX IF NOT EXISTS idx_reviews_rating 
    ON public.reviews(rating);

-- =============================================
-- VERIFICATION
-- =============================================

-- Test the functions
SELECT * FROM get_review_stats('00000000-0000-0000-0000-000000000000');

-- Check policies
SELECT policyname, cmd, qual, with_check
FROM pg_policies
WHERE schemaname = 'public' AND tablename = 'reviews';


-- =============================================
-- RECREATE CHAT TABLES
-- Run this in your Supabase SQL Editor
-- =============================================

-- Drop existing tables if they exist (in case of partial deletion)
DROP TABLE IF EXISTS public.chat_messages CASCADE;
DROP TABLE IF EXISTS public.chat_rooms CASCADE;

-- =============================================
-- CHAT ROOMS TABLE
-- =============================================
CREATE TABLE public.chat_rooms (
    id BIGSERIAL PRIMARY KEY,
    skill_1_id BIGINT REFERENCES public.skills(id) NOT NULL,
    skill_2_id BIGINT REFERENCES public.skills(id) NOT NULL,
    user_1_id UUID REFERENCES auth.users(id) NOT NULL,
    user_2_id UUID REFERENCES auth.users(id) NOT NULL,
    creator_id UUID REFERENCES auth.users(id) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    
    CONSTRAINT different_skills CHECK (skill_1_id != skill_2_id),
    CONSTRAINT different_users CHECK (user_1_id != user_2_id)
);

-- =============================================
-- CHAT MESSAGES TABLE
-- =============================================
CREATE TABLE public.chat_messages (
    id BIGSERIAL PRIMARY KEY,
    chat_room_id BIGINT REFERENCES public.chat_rooms(id) ON DELETE CASCADE NOT NULL,
    sender_id UUID REFERENCES auth.users(id) NOT NULL,
    message_text TEXT NOT NULL,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    is_read BOOLEAN DEFAULT FALSE,
    
    CONSTRAINT message_not_empty CHECK (LENGTH(TRIM(message_text)) > 0)
);

-- =============================================
-- INDEXES FOR PERFORMANCE
-- =============================================
CREATE INDEX idx_chat_rooms_users ON public.chat_rooms(user_1_id, user_2_id);
CREATE INDEX idx_chat_rooms_creator ON public.chat_rooms(creator_id);
CREATE INDEX idx_chat_rooms_updated ON public.chat_rooms(updated_at DESC);
CREATE INDEX idx_chat_messages_room_id ON public.chat_messages(chat_room_id);
CREATE INDEX idx_chat_messages_sender ON public.chat_messages(sender_id);
CREATE INDEX idx_chat_messages_sent_at ON public.chat_messages(sent_at DESC);
CREATE INDEX idx_chat_messages_is_read ON public.chat_messages(is_read);

-- Create unique index to prevent duplicate chat rooms between same users
-- This replaces the constraint that couldn't use expressions
CREATE UNIQUE INDEX idx_unique_user_pair ON public.chat_rooms (
    LEAST(user_1_id, user_2_id), 
    GREATEST(user_1_id, user_2_id)
);

-- =============================================
-- ROW LEVEL SECURITY
-- =============================================
ALTER TABLE public.chat_rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chat_messages ENABLE ROW LEVEL SECURITY;

-- Chat Rooms Policies
CREATE POLICY "Users can view rooms they're part of" ON public.chat_rooms
    FOR SELECT USING (auth.uid() = user_1_id OR auth.uid() = user_2_id);

CREATE POLICY "Users can create chat rooms" ON public.chat_rooms
    FOR INSERT WITH CHECK (auth.uid() = creator_id AND (auth.uid() = user_1_id OR auth.uid() = user_2_id));

CREATE POLICY "Users can update rooms they're part of" ON public.chat_rooms
    FOR UPDATE USING (auth.uid() = user_1_id OR auth.uid() = user_2_id);

-- Chat Messages Policies
CREATE POLICY "Users can view messages in their rooms" ON public.chat_messages
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM public.chat_rooms cr 
            WHERE cr.id = chat_room_id 
            AND (cr.user_1_id = auth.uid() OR cr.user_2_id = auth.uid())
        )
    );

CREATE POLICY "Users can send messages to their rooms" ON public.chat_messages
    FOR INSERT WITH CHECK (
        auth.uid() = sender_id AND
        EXISTS (
            SELECT 1 FROM public.chat_rooms cr 
            WHERE cr.id = chat_room_id 
            AND (cr.user_1_id = auth.uid() OR cr.user_2_id = auth.uid())
        )
    );

CREATE POLICY "Users can update own messages" ON public.chat_messages
    FOR UPDATE USING (auth.uid() = sender_id);

-- =============================================
-- TRIGGERS
-- =============================================

-- Update chat room timestamp when new message is sent
CREATE OR REPLACE FUNCTION public.update_chat_room_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.chat_rooms 
    SET updated_at = timezone('utc'::text, now())
    WHERE id = NEW.chat_room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER update_chat_room_on_message
    AFTER INSERT ON public.chat_messages
    FOR EACH ROW EXECUTE PROCEDURE public.update_chat_room_timestamp();

-- Auto-update updated_at for chat_rooms
CREATE TRIGGER handle_updated_at_chat_rooms 
    BEFORE UPDATE ON public.chat_rooms 
    FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- =============================================
-- HELPER FUNCTIONS
-- =============================================

-- Function to get or create a chat room between two users
CREATE OR REPLACE FUNCTION get_or_create_chat_room(
    p_user_1_id UUID,
    p_user_2_id UUID,
    p_skill_1_id BIGINT,
    p_skill_2_id BIGINT
)
RETURNS BIGINT AS $$
DECLARE
    v_room_id BIGINT;
    v_min_user UUID;
    v_max_user UUID;
BEGIN
    -- Ensure consistent ordering for unique constraint
    v_min_user := LEAST(p_user_1_id, p_user_2_id);
    v_max_user := GREATEST(p_user_1_id, p_user_2_id);
    
    -- Try to find existing room
    SELECT id INTO v_room_id
    FROM public.chat_rooms
    WHERE (user_1_id = v_min_user AND user_2_id = v_max_user)
       OR (user_1_id = v_max_user AND user_2_id = v_min_user);
    
    -- If not found, create new room
    IF v_room_id IS NULL THEN
        INSERT INTO public.chat_rooms (
            user_1_id,
            user_2_id,
            creator_id,
            skill_1_id,
            skill_2_id
        ) VALUES (
            v_min_user,
            v_max_user,
            auth.uid(),
            p_skill_1_id,
            p_skill_2_id
        )
        RETURNING id INTO v_room_id;
    END IF;
    
    RETURN v_room_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to mark messages as read
CREATE OR REPLACE FUNCTION mark_messages_as_read(
    p_chat_room_id BIGINT,
    p_user_id UUID
)
RETURNS VOID AS $$
BEGIN
    UPDATE public.chat_messages
    SET is_read = TRUE
    WHERE chat_room_id = p_chat_room_id
      AND sender_id != p_user_id
      AND is_read = FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get unread message count
CREATE OR REPLACE FUNCTION get_unread_count(p_user_id UUID)
RETURNS TABLE(chat_room_id BIGINT, unread_count BIGINT) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cm.chat_room_id,
        COUNT(*) as unread_count
    FROM public.chat_messages cm
    INNER JOIN public.chat_rooms cr ON cr.id = cm.chat_room_id
    WHERE (cr.user_1_id = p_user_id OR cr.user_2_id = p_user_id)
      AND cm.sender_id != p_user_id
      AND cm.is_read = FALSE
    GROUP BY cm.chat_room_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION get_or_create_chat_room TO authenticated;
GRANT EXECUTE ON FUNCTION mark_messages_as_read TO authenticated;
GRANT EXECUTE ON FUNCTION get_unread_count TO authenticated;

-- =============================================
-- VERIFICATION
-- =============================================

-- Verify tables are created
SELECT tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public' 
AND tablename IN ('chat_rooms', 'chat_messages');

-- Verify policies
SELECT tablename, policyname
FROM pg_policies
WHERE schemaname = 'public'
AND tablename IN ('chat_rooms', 'chat_messages');


-- =============================================

-- STEP 1: RUN THIS FIRST TO CLEAN UP OLD FUNCTIONS

-- =============================================

-- Drop all versions of upsert_user_profile

DROP FUNCTION IF EXISTS public.upsert_user_profile(UUID, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT[], TEXT[], JSONB[]);

DROP FUNCTION IF EXISTS public.upsert_user_profile(UUID, TEXT, TEXT, TEXT, TEXT[], TEXT[], JSONB[]);

DROP FUNCTION IF EXISTS public.upsert_user_profile;

-- Verify it's gone

SELECT routine_name, routine_type

FROM information_schema.routines

WHERE routine_schema = 'public'

AND routine_name = 'upsert_user_profile';

-- Should return empty result

-- Also clean up verify function if it exists

DROP FUNCTION IF EXISTS public.verify_user_profile(UUID);

-- Message

DO $$ 

BEGIN 

    RAISE NOTICE 'Old functions cleaned up successfully. Now run the improved functions.';

END $$;



-- =============================================
-- IMPROVED PROFILE UPSERT FUNCTION
-- First, drop the old function to avoid conflicts
-- =============================================

-- Drop the existing function (all overloads)
DROP FUNCTION IF EXISTS upsert_user_profile(UUID, TEXT, TEXT, TEXT, TEXT, TEXT, TEXT[], TEXT[], JSONB[]);
DROP FUNCTION IF EXISTS upsert_user_profile;

-- Create the improved version
CREATE OR REPLACE FUNCTION upsert_user_profile(
    p_user_id UUID,
    p_name TEXT,
    p_bio TEXT DEFAULT NULL,
    p_location TEXT DEFAULT NULL,
    p_phone_number TEXT DEFAULT NULL,
    p_profile_picture_url TEXT DEFAULT NULL,
    p_skills_to_teach TEXT[] DEFAULT '{}',
    p_skills_to_learn TEXT[] DEFAULT '{}',
    p_availability JSONB[] DEFAULT '{}'
)
RETURNS VOID AS $$
DECLARE
    skill_name TEXT;
    skill_id BIGINT;
    availability_item JSONB;
    v_profile_exists BOOLEAN;
    v_user_exists BOOLEAN;
BEGIN
    -- Check if profile exists
    SELECT EXISTS(SELECT 1 FROM public.profiles WHERE id = p_user_id) INTO v_profile_exists;
    
    -- Check if user record exists
    SELECT EXISTS(SELECT 1 FROM public.users WHERE id = p_user_id) INTO v_user_exists;
    
    -- UPSERT profiles table
    IF v_profile_exists THEN
        UPDATE public.profiles 
        SET 
            bio = p_bio,
            location = p_location,
            phone_number = p_phone_number,
            profile_picture_url = p_profile_picture_url,
            updated_at = timezone('utc'::text, now())
        WHERE id = p_user_id;
    ELSE
        INSERT INTO public.profiles (id, bio, location, phone_number, profile_picture_url)
        VALUES (p_user_id, p_bio, p_location, p_phone_number, p_profile_picture_url);
    END IF;

    -- UPSERT users table
    IF v_user_exists THEN
        UPDATE public.users 
        SET 
            name = p_name,
            updated_at = timezone('utc'::text, now())
        WHERE id = p_user_id;
    ELSE
        -- Get email from auth.users
        INSERT INTO public.users (id, email, name)
        SELECT p_user_id, email, p_name
        FROM auth.users
        WHERE id = p_user_id;
    END IF;

    -- Clear existing user skills (wrapped in transaction by caller)
    DELETE FROM public.user_skills WHERE user_id = p_user_id;

    -- Add skills to teach
    FOREACH skill_name IN ARRAY p_skills_to_teach
    LOOP
        -- Trim whitespace
        skill_name := TRIM(skill_name);
        
        IF skill_name IS NOT NULL AND skill_name != '' THEN
            -- Get or create skill
            INSERT INTO public.skills (name, category) 
            VALUES (skill_name, 'General')
            ON CONFLICT (name) DO NOTHING;
            
            SELECT id INTO skill_id 
            FROM public.skills 
            WHERE name = skill_name;
            
            -- Add user skill relationship (prevent duplicates)
            INSERT INTO public.user_skills (user_id, skill_id, skill_level)
            VALUES (p_user_id, skill_id, 'TEACH')
            ON CONFLICT DO NOTHING;
        END IF;
    END LOOP;

    -- Add skills to learn
    FOREACH skill_name IN ARRAY p_skills_to_learn
    LOOP
        -- Trim whitespace
        skill_name := TRIM(skill_name);
        
        IF skill_name IS NOT NULL AND skill_name != '' THEN
            -- Get or create skill
            INSERT INTO public.skills (name, category) 
            VALUES (skill_name, 'General')
            ON CONFLICT (name) DO NOTHING;
            
            SELECT id INTO skill_id 
            FROM public.skills 
            WHERE name = skill_name;
            
            -- Add user skill relationship (prevent duplicates)
            INSERT INTO public.user_skills (user_id, skill_id, skill_level)
            VALUES (p_user_id, skill_id, 'LEARN')
            ON CONFLICT DO NOTHING;
        END IF;
    END LOOP;

    -- Clear existing availability
    DELETE FROM public.availability WHERE user_id = p_user_id;

    -- Add new availability with validation
    FOREACH availability_item IN ARRAY p_availability
    LOOP
        -- Validate required fields
        IF (availability_item->>'day_of_week') IS NOT NULL AND
           (availability_item->>'start_time') IS NOT NULL AND
           (availability_item->>'end_time') IS NOT NULL THEN
            
            INSERT INTO public.availability (
                user_id,
                day_of_week,
                start_time,
                end_time,
                is_recurring,
                date_specific
            ) VALUES (
                p_user_id,
                availability_item->>'day_of_week',
                (availability_item->>'start_time')::TIME,
                (availability_item->>'end_time')::TIME,
                COALESCE((availability_item->>'is_recurring')::BOOLEAN, true),
                CASE 
                    WHEN availability_item->>'date_specific' IS NOT NULL 
                    THEN (availability_item->>'date_specific')::DATE 
                    ELSE NULL 
                END
            );
        END IF;
    END LOOP;

    -- Log success (optional)
    RAISE NOTICE 'Profile updated successfully for user: %', p_user_id;

EXCEPTION
    WHEN OTHERS THEN
        -- Log error and re-raise
        RAISE NOTICE 'Error in upsert_user_profile: %', SQLERRM;
        RAISE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION upsert_user_profile TO authenticated;


-- =============================================
-- ADD UNIQUE CONSTRAINT TO USER_SKILLS
-- Prevents duplicate skill assignments
-- =============================================

-- First, remove any existing duplicates
DELETE FROM public.user_skills a USING public.user_skills b
WHERE a.id > b.id 
  AND a.user_id = b.user_id 
  AND a.skill_id = b.skill_id 
  AND a.skill_level = b.skill_level;

-- Add unique constraint
ALTER TABLE public.user_skills 
ADD CONSTRAINT unique_user_skill_level 
UNIQUE (user_id, skill_id, skill_level);


-- =============================================
-- VERIFICATION FUNCTION
-- Use this to check if profile was saved correctly
-- =============================================

CREATE OR REPLACE FUNCTION verify_user_profile(p_user_id UUID)
RETURNS TABLE(
    has_profile BOOLEAN,
    has_user_record BOOLEAN,
    skill_count BIGINT,
    availability_count BIGINT,
    profile_data JSONB,
    skills_data JSONB,
    availability_data JSONB
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        EXISTS(SELECT 1 FROM public.profiles WHERE id = p_user_id) as has_profile,
        EXISTS(SELECT 1 FROM public.users WHERE id = p_user_id) as has_user_record,
        (SELECT COUNT(*) FROM public.user_skills WHERE user_id = p_user_id) as skill_count,
        (SELECT COUNT(*) FROM public.availability WHERE user_id = p_user_id) as availability_count,
        (SELECT row_to_json(p) FROM public.profiles p WHERE id = p_user_id) as profile_data,
        (SELECT jsonb_agg(jsonb_build_object(
            'skill', s.name, 
            'level', us.skill_level
        ))
        FROM public.user_skills us
        JOIN public.skills s ON s.id = us.skill_id
        WHERE us.user_id = p_user_id) as skills_data,
        (SELECT jsonb_agg(row_to_json(a))
        FROM public.availability a
        WHERE user_id = p_user_id) as availability_data;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION verify_user_profile TO authenticated;


-- =============================================
-- DEBUGGING: Enable query logging
-- Run this to see what's happening
-- =============================================

-- Create a simple logging table (optional)
CREATE TABLE IF NOT EXISTS public.debug_logs (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID,
    action TEXT,
    details JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE public.debug_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own logs" ON public.debug_logs
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert logs" ON public.debug_logs
    FOR INSERT WITH CHECK (true);

-- Step 1: Remove the NOT NULL constraints from skill IDs

ALTER TABLE public.chat_rooms 

ALTER COLUMN skill_1_id DROP NOT NULL,

ALTER COLUMN skill_2_id DROP NOT NULL;



-- Step 2: Drop the old skill constraint and add a more flexible one

-- This ensures that IF both skills are provided, they must be different.

ALTER TABLE public.chat_rooms DROP CONSTRAINT IF EXISTS different_skills;



ALTER TABLE public.chat_rooms 

ADD CONSTRAINT different_skills 

CHECK (

    (skill_1_id IS NULL OR skill_2_id IS NULL) OR 

    (skill_1_id != skill_2_id)

);



CREATE OR REPLACE FUNCTION get_or_create_chat_room(

    p_user_1_id UUID,

    p_user_2_id UUID,

    p_skill_1_id BIGINT DEFAULT NULL, -- Changed to allow NULL

    p_skill_2_id BIGINT DEFAULT NULL  -- Changed to allow NULL

)

RETURNS BIGINT AS $$

DECLARE

    v_room_id BIGINT;

    v_min_user UUID;

    v_max_user UUID;

BEGIN

    -- Ensure consistent ordering for unique constraint

    v_min_user := LEAST(p_user_1_id, p_user_2_id);

    v_max_user := GREATEST(p_user_1_id, p_user_2_id);

    

    -- Try to find existing room between these two users

    -- Note: This logic finds the room regardless of the skill context. 

    -- If you want different rooms for different skill pairs, you'd need to add skill filters here.

    SELECT id INTO v_room_id

    FROM public.chat_rooms

    WHERE (user_1_id = v_min_user AND user_2_id = v_max_user);



    -- If not found, create a new room

    IF v_room_id IS NULL THEN

        INSERT INTO public.chat_rooms (

            user_1_id,

            user_2_id,

            creator_id,

            skill_1_id,

            skill_2_id

        ) VALUES (

            v_min_user,

            v_max_user,

            auth.uid(),

            p_skill_1_id,

            p_skill_2_id

        )

        RETURNING id INTO v_room_id;

    END IF;

    

    RETURN v_room_id;

END;

$$ LANGUAGE plpgsql SECURITY DEFINER;


-- =============================================
-- FIX 1: Update chat_rooms table to make skills optional
-- =============================================

-- Drop existing constraints
ALTER TABLE public.chat_rooms 
DROP CONSTRAINT IF EXISTS different_skills;

-- Make skill columns nullable
ALTER TABLE public.chat_rooms 
ALTER COLUMN skill_1_id DROP NOT NULL,
ALTER COLUMN skill_2_id DROP NOT NULL;

-- Add flexible constraint (skills can be null OR different)
ALTER TABLE public.chat_rooms 
ADD CONSTRAINT different_skills 
CHECK (
    (skill_1_id IS NULL OR skill_2_id IS NULL) OR 
    (skill_1_id != skill_2_id)
);

-- =============================================
-- FIX 2: Updated get_or_create_chat_room function
-- This function now works WITHOUT requiring skills
-- =============================================

CREATE OR REPLACE FUNCTION get_or_create_chat_room(
    p_user_1_id UUID,
    p_user_2_id UUID,
    p_skill_1_id BIGINT DEFAULT NULL,
    p_skill_2_id BIGINT DEFAULT NULL
)
RETURNS BIGINT AS $$
DECLARE
    v_room_id BIGINT;
    v_min_user UUID;
    v_max_user UUID;
BEGIN
    -- Ensure users are different
    IF p_user_1_id = p_user_2_id THEN
        RAISE EXCEPTION 'Cannot create chat room with yourself';
    END IF;

    -- Ensure consistent ordering for unique constraint
    v_min_user := LEAST(p_user_1_id, p_user_2_id);
    v_max_user := GREATEST(p_user_1_id, p_user_2_id);
    
    -- Try to find existing room between these two users
    SELECT id INTO v_room_id
    FROM public.chat_rooms
    WHERE (user_1_id = v_min_user AND user_2_id = v_max_user);

    -- If not found, create a new room
    IF v_room_id IS NULL THEN
        INSERT INTO public.chat_rooms (
            user_1_id,
            user_2_id,
            creator_id,
            skill_1_id,
            skill_2_id
        ) VALUES (
            v_min_user,
            v_max_user,
            auth.uid(),
            p_skill_1_id,
            p_skill_2_id
        )
        RETURNING id INTO v_room_id;
    END IF;
    
    RETURN v_room_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_or_create_chat_room TO authenticated;

-- =============================================
-- FIX 3: Add helper function to get user email
-- =============================================

CREATE OR REPLACE FUNCTION get_user_email(p_user_id UUID)
RETURNS TEXT AS $$
DECLARE
    v_email TEXT;
BEGIN
    -- Get email from users table
    SELECT email INTO v_email
    FROM public.users
    WHERE id = p_user_id;
    
    -- If not found in users table, try auth.users
    IF v_email IS NULL THEN
        SELECT email INTO v_email
        FROM auth.users
        WHERE id = p_user_id;
    END IF;
    
    RETURN v_email;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_user_email TO authenticated;

-- =============================================
-- FIX 4: Verify and update RLS policies
-- =============================================

-- Drop and recreate chat_rooms policies for clarity
DROP POLICY IF EXISTS "Users can view rooms they're part of" ON public.chat_rooms;
DROP POLICY IF EXISTS "Users can create chat rooms" ON public.chat_rooms;
DROP POLICY IF EXISTS "Users can update rooms they're part of" ON public.chat_rooms;

-- Allow users to view rooms they're part of
CREATE POLICY "Users can view rooms they're part of" 
ON public.chat_rooms
    FOR SELECT 
    USING (auth.uid() = user_1_id OR auth.uid() = user_2_id);

-- Allow users to create chat rooms (they must be one of the participants)
CREATE POLICY "Users can create chat rooms" 
ON public.chat_rooms
    FOR INSERT 
    WITH CHECK (
        auth.uid() = creator_id AND 
        (auth.uid() = user_1_id OR auth.uid() = user_2_id)
    );

-- Allow users to update rooms they're part of
CREATE POLICY "Users can update rooms they're part of" 
ON public.chat_rooms
    FOR UPDATE 
    USING (auth.uid() = user_1_id OR auth.uid() = user_2_id);

-- =============================================
-- VERIFICATION QUERIES
-- =============================================

-- Test the get_or_create_chat_room function
-- Replace with actual user IDs from your database
-- SELECT get_or_create_chat_room(
--     'user-uuid-1',
--     'user-uuid-2'
-- );

-- Test the get_user_email function
-- SELECT get_user_email('your-user-uuid');

-- Check if chat rooms table is correctly structured
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_schema = 'public' 
  AND table_name = 'chat_rooms'
ORDER BY ordinal_position;

-- View all policies on chat_rooms
SELECT policyname, cmd, qual, with_check
FROM pg_policies
WHERE schemaname = 'public' 
  AND tablename = 'chat_rooms';

-- =============================================
-- CHAT REALTIME OPTIMIZATIONS
-- Run these queries to ensure optimal realtime performance
-- =============================================

-- 1. Enable Realtime for chat tables
ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_messages;
ALTER PUBLICATION supabase_realtime ADD TABLE public.chat_rooms;

-- 2. Add indexes for faster queries on chat messages
CREATE INDEX IF NOT EXISTS idx_chat_messages_room_sent 
    ON public.chat_messages(chat_room_id, sent_at DESC);

CREATE INDEX IF NOT EXISTS idx_chat_messages_unread 
    ON public.chat_messages(chat_room_id, is_read) 
    WHERE is_read = false;

-- 3. Add index for chat rooms ordering
CREATE INDEX IF NOT EXISTS idx_chat_rooms_updated_desc 
    ON public.chat_rooms(updated_at DESC);

-- 4. Optimize the get_unread_count function with better performance
CREATE OR REPLACE FUNCTION get_unread_count(p_user_id UUID)
RETURNS TABLE(chat_room_id BIGINT, unread_count BIGINT) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cm.chat_room_id,
        COUNT(*)::BIGINT as unread_count
    FROM public.chat_messages cm
    INNER JOIN public.chat_rooms cr ON cr.id = cm.chat_room_id
    WHERE (cr.user_1_id = p_user_id OR cr.user_2_id = p_user_id)
      AND cm.sender_id != p_user_id
      AND cm.is_read = false
    GROUP BY cm.chat_room_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

-- 5. Drop and recreate mark_messages_as_read function
-- (Needed because we're changing the return type)
DROP FUNCTION IF EXISTS mark_messages_as_read(BIGINT, UUID);

-- Create improved version with better tracking
CREATE OR REPLACE FUNCTION mark_messages_as_read(
    p_chat_room_id BIGINT,
    p_user_id UUID
)
RETURNS VOID AS $$
BEGIN
    -- Update messages to mark as read
    UPDATE public.chat_messages
    SET is_read = TRUE
    WHERE chat_room_id = p_chat_room_id
      AND sender_id != p_user_id
      AND is_read = FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions
GRANT EXECUTE ON FUNCTION get_unread_count TO authenticated;
GRANT EXECUTE ON FUNCTION mark_messages_as_read TO authenticated;

-- 6. Add trigger to automatically update chat_room updated_at
-- (This ensures chat rooms stay sorted correctly)
CREATE OR REPLACE FUNCTION update_chat_room_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public.chat_rooms 
    SET updated_at = timezone('utc'::text, now())
    WHERE id = NEW.chat_room_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Drop existing trigger if it exists
DROP TRIGGER IF EXISTS update_chat_room_on_message ON public.chat_messages;

-- Create new trigger
CREATE TRIGGER update_chat_room_on_message
    AFTER INSERT ON public.chat_messages
    FOR EACH ROW 
    EXECUTE FUNCTION update_chat_room_timestamp();

-- 7. Add helper function to get latest message for a room (useful for chat list)
CREATE OR REPLACE FUNCTION get_latest_message(p_room_id BIGINT)
RETURNS TABLE(
    message_text TEXT,
    sent_at TIMESTAMPTZ,
    sender_id UUID
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        cm.message_text,
        cm.sent_at,
        cm.sender_id
    FROM public.chat_messages cm
    WHERE cm.chat_room_id = p_room_id
    ORDER BY cm.sent_at DESC
    LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER STABLE;

GRANT EXECUTE ON FUNCTION get_latest_message TO authenticated;

-- 8. Create a view for efficient chat list queries
CREATE OR REPLACE VIEW chat_list_view AS
SELECT 
    cr.id as room_id,
    cr.user_1_id,
    cr.user_2_id,
    cr.updated_at,
    cr.skill_1_id,
    cr.skill_2_id,
    (
        SELECT message_text 
        FROM public.chat_messages 
        WHERE chat_room_id = cr.id 
        ORDER BY sent_at DESC 
        LIMIT 1
    ) as last_message,
    (
        SELECT sent_at 
        FROM public.chat_messages 
        WHERE chat_room_id = cr.id 
        ORDER BY sent_at DESC 
        LIMIT 1
    ) as last_message_time,
    (
        SELECT sender_id 
        FROM public.chat_messages 
        WHERE chat_room_id = cr.id 
        ORDER BY sent_at DESC 
        LIMIT 1
    ) as last_sender_id
FROM public.chat_rooms cr
ORDER BY cr.updated_at DESC;

-- Grant access to the view
GRANT SELECT ON chat_list_view TO authenticated;

-- 9. Add RLS policy for the view
ALTER VIEW chat_list_view SET (security_invoker = true);

-- 10. Verify realtime is enabled
SELECT 
    schemaname,
    tablename,
    rowsecurity
FROM pg_tables
WHERE schemaname = 'public' 
  AND tablename IN ('chat_messages', 'chat_rooms');

-- 11. Check indexes are created
SELECT 
    indexname,
    tablename,
    indexdef
FROM pg_indexes
WHERE schemaname = 'public' 
  AND tablename IN ('chat_messages', 'chat_rooms')
ORDER BY tablename, indexname;

-- =============================================
-- PERFORMANCE MONITORING QUERIES
-- Use these to check performance
-- =============================================

-- Check unread messages count for a specific user
-- SELECT * FROM get_unread_count('your-user-uuid');

-- Check latest message for a room
-- SELECT * FROM get_latest_message(1);

-- View all active chat rooms with details
-- SELECT * FROM chat_list_view LIMIT 10;

-- Check message count per room
-- SELECT 
--     chat_room_id,
--     COUNT(*) as message_count,
--     MAX(sent_at) as latest_message
-- FROM public.chat_messages
-- GROUP BY chat_room_id
-- ORDER BY latest_message DESC;

-- =============================================
-- TROUBLESHOOTING
-- =============================================

-- If realtime updates aren't working, check:
-- 1. Verify Supabase Realtime is enabled in project settings
-- 2. Check if tables are added to realtime publication:
SELECT * FROM pg_publication_tables WHERE pubname = 'supabase_realtime';

-- 3. Verify RLS policies allow SELECT on chat tables:
SELECT schemaname, tablename, policyname, permissive, roles, cmd
FROM pg_policies
WHERE schemaname = 'public' 
  AND tablename IN ('chat_messages', 'chat_rooms')
  AND cmd = 'SELECT';

-- =============================================
-- CLEANUP (if needed)
-- =============================================

-- To remove the view:
-- DROP VIEW IF EXISTS chat_list_view;

-- To remove helper function:
-- DROP FUNCTION IF EXISTS get_latest_message(BIGINT);
